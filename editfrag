#!/usr/bin/env perl

#
#	editfrag			Version 20160527
#
#   * 特定フラグメントのみの PDB を読み込ませることによって、fred ファイルを再構築できる
#	* fred プログラムの擬似GUI化プログラム
#


use strict;

my $base_pdb = "";
my $frag_pdb = "";
my $fred = "";

my $flag_arg = 0;
foreach my $arg (@ARGV){
	if(($arg =~ /^--help$/i) || ($arg =~ /^-H$/i)){
		&help();
		exit;
	}
	elsif($arg =~ /^-b$/i){
		$flag_arg = 1;
	}
	elsif($arg =~ /^-n$/i){
		$flag_arg = 2;
	}
	elsif($arg =~ /^-f$/i){
		$flag_arg = 3;
	}
	elsif($flag_arg == 1){
		$base_pdb = &check_file($arg);
	}
	elsif($flag_arg == 2){
		$frag_pdb = &check_file($arg);
	}
	elsif($flag_arg == 3){
		$fred = &check_file($arg);
	}
}

if(($base_pdb eq "") || ($frag_pdb eq "") || ($fred eq "")){
	print STDERR "ERROR: Not enough arguments\n";
	exit;
}


# 新フラグメントファイル読み込み
my @resnames = ();
my @resnums = ();
my @coords = ();
open(IN, $frag_pdb);
while(my $line = <IN>){
	if($line =~ /^((ATOM)|(HETATM))/){
		push(@resnames, substr($line, 17, 3));
		push(@resnums, substr($line, 22, 4));
		push(@coords, substr($line, 30, 24));
	}
}
close(IN);

# FMO に使うベースとなる PDB
my @atoms = ();
open(IN, $base_pdb);
while(my $line = <IN>){
	if($line =~ /^((ATOM)|(HETATM))/){
		my $resname = substr($line, 17, 3);
		my $resnum = substr($line, 22, 4);
		my $coord = substr($line, 30, 24);

		# 新フラグメントファイルと同一の原子かチェック
		my $match = 0;
		for (my $i = 0; $i < scalar(@coords); $i++) {
			if(($resname eq $resnames[$i]) && ($resnum eq $resnums[$i]) && ($coord eq $coords[$i])){
				$match = 1;
				last;
			}
		}

		if($match == 1){
			my $atom = substr($line, 6, 5);
			$atom =~ s/[\s\t]+//g;
			push(@atoms, $atom);
		}
	}
}
close(IN);

# fred ファイル内の重複削除と新フラグメントの追加
my $flag_read = 0;
my $last_frag = 0;
open(IN, $fred);
while(my $line = <IN>){
	if($line =~ /^[\s\t]*\d+[\s\t]*\|[\s\t]*-?\w+[\s\t]*\|[\s\t]*\w+[\s\t]*\|([\s\t]*\d+)+/){	# フラグメント情報
		my @lines = split(/[\s\t]*\|[\s\t]*/, $line);	# | で区切って各データを格納
		$last_frag = $lines[0];
		$lines[3] =~ s/[\s\t]*\n$//;
		my @datas = split(/[\s\t]+/, $lines[3]);	# フラグメント構成原子を配列に格納
		for (my $i = 0; $i < scalar(@atoms); $i++) {	# 新しく定義するフラグメントの原子順序番号でループ
			my @results = grep {$atoms[$i] == $datas[$_]} 0..$#datas;	# 新しく定義するフラグメントの原子順序番号と、現在のフラグメント構成原子情報で重複する原子をリストアップ
			if(scalar(@results) != 0){	# 新フラグメントと重複する原子があった場合
				for (my $j = $#results; 0 <= $j; $j--) {	# 結果の後ろから順に削除 (前からだと)
					splice(@datas, $results[$j], 1);
					$lines[1] = "*";	# 構成原子に変更があったため、電荷値変更
					$lines[2] = "*";	# 構成原子に変更があったため、BDA 変更
				}
			}
		}
		if(scalar(@datas) != 0){	# 構成原子がある場合(重複により原子がなくなったら、フラグメントは削除(出力しない))
			for (my $i = 0; $i < scalar(@datas); $i++) {	# フラグメント構成原子情報の再構築
				$datas[$i] = sprintf("%5s", $datas[$i]);
				$lines[3] = join(" ", @datas);
			}
			printf("%6s  |%5s   |%3s  | %s\n", @lines);
		}
		$flag_read = 1;
	}
	elsif($flag_read == 1){		# これまでフラグメントデータの次の行(PDBのフラグメントの追加)
		$last_frag ++;
		my @lines = ($last_frag, "*", "*", "");
		for (my $i = 0; $i < scalar(@atoms); $i++) {	# フラグメント構成原子情報の再構築
			$atoms[$i] = sprintf("%5s", $atoms[$i]);
			$lines[3] = join(" ", @atoms);
		}
		print STDERR "Added new fragment as fragment No. $last_frag\n";
		printf("%6s  |%5s   |%3s  | %s\n", @lines);
		print $line;
		$flag_read = 0;
	}
	elsif($line =~ /^[\s\t]*\d+[\s\t]*-[\s\t]*\d+/){	# 接続情報
		$flag_read = 2;
		print $line;
	}
	elsif($flag_read == 2){
		print "     * -      *\n";
		print $line;
		$flag_read = 0;
	}
	else{
		print $line;
	}
}
close(IN);


# ===== check_file ===== #
sub check_file(){
	if(! -f $_[0]){
		print STDERR "ERROR: No such file ($_[0])\n";
		exit;
	}

	return $_[0];
}

# ===== help ===== #
sub help(){
print << "HELP";
 \$ editfrag -f FRED_FILE -b PDB_FILE -n PDB_FILE > NEW_FRED


HELP
}
