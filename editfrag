#!/usr/bin/env perl

#
#	editfrag			Version 20160527
#
#   * 特定フラグメントのみの PDB を読み込ませることによって、fred ファイルを再構築できる
#	* fred プログラムの擬似GUI化プログラム
#


use strict;

my $base_pdb = "";
my @frag_pdbs = ();
my $fred = "";

my $flag_arg = 0;
foreach my $arg (@ARGV){
	if(($arg =~ /^--help$/i) || ($arg =~ /^-H$/i)){
		&help();
		exit;
	}
	elsif($arg =~ /^-b$/i){
		$flag_arg = 1;
	}
	elsif($arg =~ /^-n$/i){
		$flag_arg = 2;
	}
	elsif($arg =~ /^-f$/i){
		$flag_arg = 3;
	}
	elsif($flag_arg == 1){
		$base_pdb = &check_file($arg);
		$flag_arg = 0;
	}
	elsif($flag_arg == 2){
		push(@frag_pdbs, &check_file($arg));
	}
	elsif($flag_arg == 3){
		$fred = &check_file($arg);
		$flag_arg = 0;
	}
}

if(($base_pdb eq "") || (scalar(@frag_pdbs) == 0) || ($fred eq "")){
	print STDERR "ERROR: Not enough arguments\n";
	exit;
}


# 新フラグメントファイル読み込み
my @atoms = ();	# ファイル(フラグメント)ごとの原子順序番号
my @resnames = ();	# ファイル(フラグメント)ごとの残基名を格納した2次配列
my @resnums = ();	# ファイル(フラグメント)ごとの残基番号を格納した2次配列
my @coords = ();	# ファイル(フラグメント)ごとの座標を格納した2次配列
foreach my $frag_pdb (@frag_pdbs){
	my @atoms_u = ();
	my @resnames_u = ();
	my @resnums_u = ();
	my @coords_u = ();
	open(IN, $frag_pdb);
	while(my $line = <IN>){
		if($line =~ /^((ATOM)|(HETATM))/){
			push(@atoms_u, substr($line, 6, 5));
			push(@resnames_u, substr($line, 17, 3));
			push(@resnums_u, substr($line, 22, 4));
			push(@coords_u, substr($line, 30, 24));
		}
	}
	close(IN);

	push(@atoms, [@atoms_u]);
	push(@resnames, [@resnames_u]);
	push(@resnums, [@resnums_u]);
	push(@coords, [@coords_u]);
}


# FMO に使うベースとなる PDB
my @check_atoms = ();	# fred 内の重複チェック用
open(IN, $base_pdb);
while(my $line = <IN>){
	if($line =~ /^((ATOM)|(HETATM))/){
		my $resname = substr($line, 17, 3);
		my $coord = substr($line, 30, 24);

		# 新フラグメントファイルと同一の原子かチェック
		for (my $i = 0; $i < scalar(@coords); $i++) {
			for (my $j = 0; $j < scalar(@{$coords[$i]}); $j++) {
				if(($resname eq $resnames[$i][$j]) && ($coord eq $coords[$i][$j])){
					my $atom = substr($line, 6, 5);
					$atom =~ s/[\s\t]+//g;
					$atoms[$i][$j] = $atom;
					push(@check_atoms, $atom);
					last;
				}
			}
		}
	}
}
close(IN);


# fred ファイル内の重複削除と新フラグメントの追加
my $flag_read = 0;
my $last_frag = 0;
open(IN, $fred);
while(my $line = <IN>){
	if($line =~ /^[\s\t]*\d+[\s\t]*\|[\s\t]*-?\w+[\s\t]*\|[\s\t]*\w+[\s\t]*\|([\s\t]*\d+)+/){	# フラグメント情報
		my @lines = split(/[\s\t]*\|[\s\t]*/, $line);	# | で区切って各データを格納
		$last_frag = $lines[0];
		$lines[3] =~ s/[\s\t]*\n$//;
		my @datas = split(/[\s\t]+/, $lines[3]);	# フラグメント構成原子を配列に格納
		for (my $i = 0; $i < scalar(@check_atoms); $i++) {	# 新しく定義するフラグメントの原子順序番号でループ
			my @results = grep {$check_atoms[$i] == $datas[$_]} 0..$#datas;	# 新しく定義するフラグメントの原子順序番号と、現在のフラグメント構成原子情報で重複する原子をリストアップ
			if(scalar(@results) != 0){	# 新フラグメントと重複する原子があった場合
				for (my $j = $#results; 0 <= $j; $j--) {	# 結果の後ろから順に削除 (前からだと)
					splice(@datas, $results[$j], 1);
					$lines[1] = "*";	# 構成原子に変更があったため、電荷値変更
					$lines[2] = "*";	# 構成原子に変更があったため、BDA 変更
				}
			}
		}
		if(scalar(@datas) != 0){	# 構成原子がある場合(重複により原子がなくなったら、フラグメントは削除(出力しない))
			for (my $i = 0; $i < scalar(@datas); $i++) {	# フラグメント構成原子情報の再構築
				$datas[$i] = sprintf("%8s", $datas[$i]);
				$lines[3] = join(" ", @datas);
			}
			printf("%7s |%6s  |%3s  |%s\n", @lines);
		}
		$flag_read = 1;
	}
	elsif($flag_read == 1){		# これまでフラグメントデータの次の行(PDBのフラグメントの追加)
		for (my $i = 0; $i < scalar(@atoms); $i++) {	# フラグメント構成原子情報の再構築
			my @lines = ($last_frag + $i + 1, "*", "*", "");
			for (my $j = 0; $j < scalar(@{$atoms[$i]}); $j++) {
				$atoms[$i][$j] = sprintf("%8s", $atoms[$i][$j]);
				$lines[3] = join(" ", @{$atoms[$i]});
			}
			print STDERR "Added new fragment (", $frag_pdbs[$i], ") as fragment No. ", $last_frag + $i + 1, "\n";
			printf("%7s |%6s  |%3s  |%s\n", @lines);
		}
		print $line;
		$flag_read = 0;
	}
	elsif($line =~ /^[\s\t]*\d+[\s\t]*[\s\t]*\d+/){	# 接続情報
		$flag_read = 2;
		print $line;
	}
	elsif($flag_read == 2){
		for (my $i = 0; $i < scalar(@atoms); $i++) {
			printf(" %7s %7s\n", "*", "*");
		}
		print $line;
		$flag_read = 0;
	}
	else{
		print $line;
	}
}
close(IN);


# ===== check_file ===== #
sub check_file(){
	if(! -f $_[0]){
		print STDERR "ERROR: No such file ($_[0])\n";
		exit;
	}

	return $_[0];
}

# ===== help ===== #
sub help(){
print << "HELP";
 \$ editfrag -f FRED_FILE -b PDB_FILE -n PDB_FILE1 [PDB_FILE2 ...] > NEW_FRED


HELP
}
