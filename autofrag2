#! /usr/bin/env perl

###########################################################################
##
##	autofrag プログラム					Last Update 2015/07/08
##	PDBファイルを入力ファイルとし、fred の編集形式で出力します。
##	ABINIT-MP の autofrag の結果が気に食わない時に使うと便利です。
##	 $ autofrag [-s] <PDBファイル> [> <出力ファイル>]
##
##	Option:
##		-s, --separate: Nucleotide is separates to base and sugar+phosphate
##						* Sugar is recognized atomtype like xx'
##
###########################################################################

use strict;
use File::Basename;

if(($ARGV[0] =~ /^--help$/i) || ($ARGV[0] =~ /^-H$/i)){
	&help;
	exit;
}


my $flag_sep = 0;
my $flag_arg = 0;
my $version = "3";
my $in = "";
foreach my $arg (@ARGV){
	if(($arg =~ /^--separate$/i) || ($arg =~ /^-S$/i)){
		$flag_sep = 1;
	}
	elsif(($arg =~ /^--version$/i) || ($arg =~ /^-V$/i)){
		$flag_arg = 1;
	}
	elsif($flag_arg == 1){
		if($arg =~ /^[35m]$/i){
			$version = $arg
		}
		else{
			print STDERR "ERROR: Unknown version\n";
			exit;
		}
		$flag_arg = 0;
	}
	else{
		$in = &check_file($arg);
	}
}


my @fragments = ("TER");		# 全てのフラグメントの原子順序番号
my @connectivities = ();		# 全てのフラグメントの接続情報
my @bdas = ();					# 全ての BDA
my @charges = ();				# 全ての電荷情報
my @residue_names = ("TER");	# 全ての残基名
my @ligands = ();				# リガンド

my $cpf = $in;					# CPF ファイル
$cpf =~ s/\.pdb$/.cpf/;
my $title = $in;				# タイトル
$title =~ s/\.pdb//;
my $total_atom = 0;				# 全原子数
my $total_fragment = 0;			# 全フラグメント数
my $total_charge = 0;			# 全電荷数
my $residue_type_old = "";		# 直前に処理した残基の種類
my $residue_info_old = "";		# 直前に処理した残基情報
my $hip = 0;					# HIP フラグ

my @fragments_tmp = ();			# 作業中のフラグメントの原子順序番号
my @fragments_tmp_s = ();		# 同時作業中のフラグメントの原子順序番号
my $connectivity_tmp = 0;		# フラグメント結合
my $connectivity_tmp_s = 0;
open(IN, $in);
while(<IN>){
	my $line = $_;
	$line =~ s/\n//;

	if(/^(ATOM)|(HETATM)/i){
		# 全原子をカウント
		$total_atom ++;

		# 原子順序番号取得
		my $atom_order = substr($line, 6, 5);
		$atom_order =~ s/\s//g;

		# アトムタイプ取得
		my $atom_type = substr($line, 12, 4);
		$atom_type =~ s/\s//g;

		# 残基名取得
		my $residue_info = substr($line, 17, 9);
		my $residue_name = substr($residue_info, 0, 3);
		$residue_name =~ s/\s//g;
		$residue_name =~ s/[-\+\*\'\"]//g;

		# 残基の種類照合
		my $residue_type = &check_residue($residue_name);

		# アミノ酸の処理
		if($residue_type == 1){
			# 前回、別の種類の残基を前回処理したままの場合(フラグメントデータ登録)
			if($residue_type_old != 1){
				# フラグメントデータの登録
				push(@fragments, join(" ", @fragments_tmp));
				@fragments_tmp = ();
				if($#fragments_tmp_s != -1){
					push(@fragments, join(" ", @fragments_tmp_s));
					@fragments_tmp_s = ();
					#push(@residue_names, "DNA_base");
					splice(@residue_names, $#residue_names, 0, "DNA_base");
				}
				push(@fragments, "TER");

				# 残基名登録
				push(@residue_names, "TER");

				# 今のデータを登録
				push(@fragments_tmp, $atom_order);
			}
			# 前回、同じアミノ酸を処理していた場合で、かつ C 原子を扱っている場合、フラグメントを分割
			elsif($atom_type eq "C"){
				# 前回の処理(フラグメントデータ登録)(初回処理は見逃す)
				if($#fragments_tmp != -1){
					# フラグメントデータの登録
					push(@fragments, join(" ", @fragments_tmp));
					@fragments_tmp = ();

					# 今のデータを登録
					push(@fragments_tmp, $atom_order);
				}
			}
			# その他の通常原子の場合
			else{
				# 今のデータを登録
				push(@fragments_tmp, $atom_order);
			}

			# 接続情報のための処理
			# 接続元
			if($atom_type eq "CA"){
				$connectivity_tmp = $atom_order;
			}
			# 接続先
			elsif(($atom_type eq "C") && ($residue_name !~ /^ACE$/)){
				# 接続情報登録
				push(@connectivities, join(" ", $connectivity_tmp, $atom_order));
				$connectivity_tmp = 0;
			}
			# 非電荷 N 末端残基の場合の処理
			elsif(($atom_type eq "N") && ($residue_name =~ /^((NME)|(NHH))$/)){
				pop(@connectivities);
			}
		}

		# 核酸の処理
		elsif($residue_type == 2){
			# 前回、別の種類の残基を前回処理したままの場合(フラグメントデータ登録)
			if($residue_type_old != 2){
				# フラグメントデータの登録
				push(@fragments, join(" ", @fragments_tmp));
				@fragments_tmp = ();
				if($#fragments_tmp_s != -1){
					push(@fragments, join(" ", @fragments_tmp_s));
					@fragments_tmp_s = ();
					#push(@residue_names, "DNA_base");
					splice(@residue_names, $#residue_names, 0, "DNA_base");
				}
				push(@fragments, "TER");
				push(@residue_names, "TER");

				# 今のデータを登録
				push(@fragments_tmp, $atom_order);
			}
			# 前回、同じ核酸を処理していた場合で、かつ C4' 原子を扱っている場合、フラグメントを分割
			elsif(($atom_type =~ /^(C4['\*])$/) && ($residue_name !~ /^D.5$/)){
				# 前回の処理(フラグメントデータ登録)(初回処理は見逃す)
				if($#fragments_tmp != -1){
					# フラグメントデータの登録
					push(@fragments, join(" ", @fragments_tmp));
					@fragments_tmp = ();
					if($#fragments_tmp_s != -1){
						push(@fragments, join(" ", @fragments_tmp_s));
						splice(@residue_names, $#residue_names, 0, "DNA_base");
						#push(@residue_names, "DNA_base");
						@fragments_tmp_s = ();
					}

					# 今のデータを登録
					push(@fragments_tmp, $atom_order);
				}
			}
			# その他の通常原子の場合
			else{
				# 今のデータを登録
				if($flag_sep == 1){
					if(($atom_type =~ /'/) || ($atom_type =~ /P/) || ($atom_type =~ /^\s*H[35]T\s*$/)){
						push(@fragments_tmp, $atom_order);
					}
					else{
						push(@fragments_tmp_s, $atom_order);
					}
				}
				else{
					push(@fragments_tmp, $atom_order);
				}
			}

			# 接続情報のための処理
			# 接続元
			if(($atom_type =~ /^C5[\'\*]$/) && ($residue_name !~ /^(([DR]A)|([DR]G)|([DR]C)|(DT)|(RU))5$/)){
				$connectivity_tmp = $atom_order;
			}
			# 接続先
			elsif(($atom_type =~ /^C4[\'\*]$/) && ($residue_name !~ /^(([DR]A)|([DR]G)|([DR]C)|(DT)|(RU))5$/)){
				# 接続情報登録
				push(@connectivities, join(" ", $connectivity_tmp, $atom_order));
				$connectivity_tmp = 0;
			}
			elsif($flag_sep == 1){
				if($atom_type =~ /^C1[\'\*]$/){
					$connectivity_tmp = $atom_order;
				}
				elsif(($atom_type =~ /^N1$/) && ($residue_name =~ /^D[CT][35]?$/)){
					# 接続情報登録
					push(@connectivities, join(" ", $connectivity_tmp, $atom_order));
					$connectivity_tmp = 0;
				}
				elsif(($atom_type =~ /^N9$/) && ($residue_name =~ /^D[AG][35]?$/)){
					# 接続情報登録
					push(@connectivities, join(" ", $connectivity_tmp, $atom_order));
					$connectivity_tmp = 0;
				}
			}
		}

		# 水分子の処理
		elsif($residue_type == 3){
			# 前回、別の種類の残基を前回処理したままの場合(フラグメントデータ登録)
			if($residue_type_old != 3){
				# フラグメントデータの登録
				push(@fragments, join(" ", @fragments_tmp));
				@fragments_tmp = ();
				if($#fragments_tmp_s != -1){
					push(@fragments, join(" ", @fragments_tmp_s));
					@fragments_tmp_s = ();
					#push(@residue_names, "DNA_base");
					splice(@residue_names, $#residue_names, 0, "DNA_base");
				}
				push(@fragments, "TER");
				push(@residue_names, "TER");

				# 今のデータを登録
				push(@fragments_tmp, $atom_order);
			}
			# 前回、同じ水分子を処理していた場合で、かつ O 原子を扱っている場合、フラグメントを分割
			elsif($atom_type =~ /^OW?$/){
				# 前回の処理(フラグメントデータ登録)(初回処理は見逃す)
				if($#fragments_tmp != -1){
					# フラグメントデータの登録
					push(@fragments, join(" ", @fragments_tmp));
					@fragments_tmp = ();

					# 今のデータを登録
					push(@fragments_tmp, $atom_order);
				}
			}
			# その他の通常原子の場合
			else{
				# 今のデータを登録
				push(@fragments_tmp, $atom_order);
			}
		}

		# イオンの処理
		elsif($residue_type == 4){
			# 前回、別の種類の残基を前回処理したままの場合(フラグメントデータ登録)
			if($residue_type_old != 4){
				# フラグメントデータの登録
				push(@fragments, join(" ", @fragments_tmp));
				@fragments_tmp = ();
				if($#fragments_tmp_s != -1){
					push(@fragments, join(" ", @fragments_tmp_s));
					@fragments_tmp_s = ();
					#push(@residue_names, "DNA_base");
					splice(@residue_names, $#residue_names, 0, "DNA_base");
				}
				push(@fragments, "TER");
				push(@residue_names, "TER");
			}
			# 今のデータを登録
			push(@fragments, $atom_order);
		}

		# その他の分子の処理
		else{
			# 今のデータを登録
			push(@fragments_tmp, $atom_order);
		}

		# 現在の処理残基の種類を登録
		$residue_type_old = $residue_type;

		if($residue_info ne $residue_info_old){
			# 残基名登録
			push(@residue_names, $residue_name);
			# 現在の処理残基の名前を登録
			$residue_info_old = $residue_info;
		}

	}

	# TER の場合、強制的にフラグメント分割
	if(/^TER/){
		# フラグメントデータの登録
		push(@fragments, join(" ", @fragments_tmp));
		@fragments_tmp = ();
		if($#fragments_tmp_s != -1){
			push(@fragments, join(" ", @fragments_tmp_s));
			@fragments_tmp_s = ();
			push(@residue_names, "DNA_base");
			#splice(@residue_names, $#residue_names, 0, "DNA_base");
		}
		push(@fragments, "TER");
		push(@residue_names, "TER");
		$connectivity_tmp = 0;
		$residue_type_old = 0;
	}
}
close(IN);

if($#fragments_tmp != -1){
	# フラグメントデータの登録
	push(@fragments, join(" ", @fragments_tmp));
}

# 空白の配列を除去
my $i = 0;
while($i <= $#fragments){
	if($fragments[$i] =~ /^$/){
		splice(@fragments, $i, 1);
		next;
	}
	$i ++;
}

# 非電荷末端アミノ酸のマージ
$i = 0;
while($i <= $#residue_names){
	if($residue_names[$i] =~ /^ACE$/){
		# ACE は削除
		splice(@residue_names, $i, 1);

		# fragment 情報をマージ
		$fragments[$i] = join(" ", $fragments[$i], $fragments[$i + 1]);
		splice(@fragments, $i + 1, 1);

		next;
	}
	elsif($residue_names[$i] =~ /^(NME)|(NHH)$/){
		# NME/NHH は削除
		splice(@residue_names, $i, 1);

		# fragment 情報をマージ
		$fragments[$i - 1] = join(" ", $fragments[$i - 1], $fragments[$i]);
		splice(@fragments, $i, 1);

		next;
	}
	$i ++;
}

# 電荷と BDA (核酸の電荷については補正せずに、最初から補正済みの値を与える)
$i = 0;
foreach(@residue_names){
	if($_ !~ /^TER$/){
		my $charge = &identify_charge($_, $flag_sep);
		my $residue_type = &check_residue($_);

		# アミノ酸の場合
		if($residue_type == 1){
			# 最初のフラグメントの処理
			if($residue_names[$i - 1] =~ /^TER$/){
				$charge += 1;

				# BDA 登録(N 末端)
				push(@bdas, 0);
			}
			# 最後のフラグメントの処理
			elsif($residue_names[$i + 1] =~ /^TER$/){
				$charge -= 1;

				# BDA 登録(C 末端)
				push(@bdas, 1);
			}
			# その他のフラグメントの処理
			else{
				# BDA 登録(通常残基)
				push(@bdas, 1);
			}

			# HIP の場合
			if($residue_names[$i] eq "HIP"){
				$hip = 1;
			}
		}
		# 核酸の場合
		elsif($residue_type == 2){
			# 最初のフラグメントの処理
			if($residue_names[$i - 1] =~ /^TER$/){
				# BDA 登録(5'-末端)
				push(@bdas, 0);
			}
			# 最後のフラグメントの処理
			elsif($residue_names[$i + 1] =~ /^TER$/){
				# BDA 登録(3'-末端)
				push(@bdas, 1);
			}
			# その他のフラグメントの処理
			else{
				# BDA 登録(通常塩基)
				push(@bdas, 1);
			}
		}
		# 水分子の場合
		elsif($residue_type == 3){
			# BDA 登録(水分子)
			push(@bdas, 0);
		}
		# イオンの場合
		elsif($residue_type == 4){
			# BDA 登録(イオン)
			push(@bdas, 0);

			# リガンド電荷用に登録
			push(@ligands, $_ . "=" . $charge);
		}
		# その他の分子の場合
		elsif($residue_type == 5){
			# BDA 登録(リガンド)
			push(@bdas, 0);

			# リガンド電荷用に登録
			push(@ligands, $_ . "=0");
		}

		# 電荷登録
		push(@charges, $charge);

		# 全電荷計算
		$total_charge += $charge;
	}
	else{
		push(@charges, "TER");
		push(@bdas, "TER")
	}
	$i ++;
}

# リガンド電荷のフォーマット用処理
$i = 0;
my $old = "";	# 過去のデータ

# リガンドデータソート
@ligands = sort(@ligands);
while($i <= $#ligands){
	# 前と同じリガンドの場合、削除
	if($old eq $ligands[$i]){
		splice(@ligands, $i, 1);
		next;
	}
	$old = $ligands[$i];
	$i ++;
}

# HIP もリガンド電荷に登録
if($hip == 1){
	unshift(@ligands, "HIP=1");
}
my $ligand = join(",", @ligands);
undef $old;
undef @ligands;

# 出力
print "  FNo.  | charge | BDA | atoms of fragment\n";

# フラグメント構成の出力
$i = 0;
foreach(@fragments){
	if($_ !~ /^TER$/){
		# 全フラグメント計算
		$total_fragment ++;

		# 整形
		my $frag_no = sprintf("%7s", $total_fragment);
		if($charges[$i] eq "TER"){
			$charges[$i] = "ERR";
			print STDERR " WARNING: 分割方法が不明で電荷を特定できないフラグメントが存在します($frag_no)\n";
		}
		$charges[$i] = sprintf("%5s", $charges[$i]);

		if($bdas[$i] eq "TER"){
			$bdas[$i] = "ER";
			print STDERR " WARNING: 分割方法が不明でBDAを特定できないフラグメントが存在します($frag_no)\n";
		}
		else{
			$bdas[$i] = sprintf("%2s", $bdas[$i]);
		}

		my @fragment_elems = split(/\s/, $fragments[$i]);
		foreach(@fragment_elems){
			$_ = sprintf("%7s", $_);
		}
		$fragments[$i] = join(" ", @fragment_elems);

		print "$frag_no | $charges[$i]  | $bdas[$i]  | $fragments[$i]\n";
	}
	$i ++;
}

# 接続情報の出力
print "\n<< Conection >>\n";
foreach(@connectivities){
	# 整形
	my @datas = split(/\s/, $_);
	$datas[0] = sprintf("%6s", $datas[0]);
	$datas[1] = sprintf("%6s", $datas[1]);

	print join(" - ", @datas), "\n";
}

# 計算オプションの出力
my $option_nuc = "+base";
if($flag_sep == 1){
	$option_nuc = "/base";
}

if($version eq "3"){
print << "AJF";

-------------------------------------------------------------------------
  Total atom     : $total_atom
  Total fragment : $total_fragment
  System charge  : $total_charge
-------------------------------------------------------------------------

 << OPTION >>
&OPTION
Title='$title'
ReadGeom='$in'
WriteGeom='$cpf'

Charge=$total_charge
LigandCharge='$ligand'
Natom=$total_atom
Nf=$total_fragment

Memory=1900
Np=1
Nprint=3

FMO='ON'
AutoFrag='OFF'
FragSizeResidue=1
FragSizeNucleotide='$option_nuc'

Method='HF' BasisSet='6-31G'

Layer=2
MethodL2='MP2'
FragL2=''

ElecState='S1'
DirectSCF='semi'
MaxScfEnergy=1.0E-8 MaxScfDensity=1.0E-6 MaxScfCyc=500
VShift=0.0 KShift=0.0 LShift=0.0
AlterMO='0,0'
MaxCyc=-1
MaxSccCyc=250 MaxSccEnergy=5.0E-7
ApproxLevel=3
Laoc=0.0  Lptc=2.0 Ldimer=2.0
/
AJF
}
elsif($version eq "m"){
print << "AJF";
&CNTRL
  Title='$title'
  ElecState='S1'
  Method='MP2'
  Nprint=3
  Memory=1600
  Natom=$total_atom
  Charge=$total_charge
  ReadGeom='$in'
  WriteGeom='$cpf'
  Gradient='NO'
  Vector='OFF'
  CPFBIN='NO'
/

&FMOCNTRL
  FMO='ON'
  FMO3='OFF'
  AutoFrag='OFF'
  FragSizeResidue=1
  FragSizeNucleotide='$option_nuc'
  NF=$total_fragment
  LigandCharge='$ligand'
  Lptc=2.0
  Laoc=0.0
  Ldimer=2.0
  Dimer_es_multipole='NO'
  NP=1
  MaxSCCcyc=250
  MaxSccEnergy=5.0E-7
  Lbuf=2.0
  NBody=2
  FragSizeAminoacid='+amino'
  esp_ptc_multipole='NO'
  MaxSCCenergy=5.0E-7
  LMOTYP='ANO'
/

&SCF
  MaxSCFenergy=1.0E-8
  MaxSCFdensity=1.0E-6
  MaxSCFcyc=500
  AlterMO='0,0'
  VShift=0.0
  KShift=0.0
  LShift=0.0
  IFCD='YES'
  THCDINT=0.0010
  THCDLD=1.0E-6
  NCDBLK=50
  CDHF='NO'
  CDGRAD='NO'
  THINTEG=1.0E-12
  DIISTYPE='C2_OLD'
/

&BASIS
  BasisSet='6-31G*'
  DiffuseOn='NO'
/

&OPTCNTRL
  OPT='OFF'
  MaxCyc=-1
/

&MLFMO
/

&XUFF
/

&MP2
  NP_MP2_I=1
  NP_MP2_IJ=1
  NP_MP2_S=0
  LPRINT=2
  MP2_2BODY='NO'
  NBODY=2
  MemoryMP2=0
  PSSCAL=1.0
  CHKFZC='YES'
  OSSCAL=1.0
  IFSCS='YES'
/

&MP2DNS
/

&MP2GRD
/

&MP3
/

&LMP2
/

&DFT
/

&PIEDA
  EnergyDecomposition='NO'
/

&BSSE
  CP='OFF'
/

&FRAGPAIR
/

&SOLVATION
  EFFECT='OFF'
/

&PBEQ
  JDGCNV='RMS'
  MAXITR=1000
  THRCNV=1.0E-5
/

&POP
  NBOANL='OFF'
  ESPFIT='OFF'
/

&GRIDCNTRL
  GRID='NO'
/

&MCP
/

&CIS
/

&CISGRD
/

&CAFI
  LPRINT=2
  METLOC='PIPE'
  CHKFZC='NO'
  IFLOC='OCC'
/

&POL
/

&GF2
/

&CCPT
/

&XYZ
/
&FRAGMENT
{...}
/

&MDCNTRL
/

AJF
}



exit;

# =============== identify_charge =============== #
# 電荷
sub identify_charge{
	my $residue_name = shift(@_);
	my $flag_sep = shift(@_);

	if($residue_name =~ /^((LYS)|(ARG)|(HIP)|(SYM))$/){
		return 1;	# 電荷
	}
	elsif($residue_name =~ /^((ASP)|(GLU))$/){
		return -1;	# 電荷
	}
	elsif($residue_name =~ /^(([DR]A)|([DR]G)|(DT)|([DR]C)|(RU))5$/){
		if($flag_sep == 0){
			return 0;	# 電荷
		}
		else{
			return 1;	# 電荷
		}
	}
	elsif($residue_name =~ /^(([DR]A)|([DR]G)|(DT)|([DR]C)|(RU))3?$/){
		if($flag_sep == 0){
			return -1;	# 電荷
		}
		else{
			return 0;	# 電荷
		}
	}
	elsif($residue_name =~ /^((Na)|(K))$/i){
		return 1;	# 電荷
	}
	elsif($residue_name =~ /^((Zn)|(Ca)|(CAL)|(ZIN))$/i){
		return 2;	# 電荷
	}
	elsif($residue_name =~ /^DNA_base$/i){
		return -1;	# 電荷
	}
	else{
		return 0;
	}
}

# =============== check_residue =============== #
# 残基チェック
sub check_residue{
my $residue_name = shift(@_);

my @amino_acids = ("ACE", "ALA", "ARG", "ASN", "ASP", "CYS", "GLN", "GLU", "GLY", "HIS", "HIP", "HID", "HIE", "ILE", "LEU", "LYS", "MET", "NME", "PHE", "PRO", "SER", "THR", "TRP", "TYR", "VAL");
my @nucleic_acids = ("DA5", "DT5", "DG5", "DC5", "DA3", "DT3", "DG3", "DC3", "DA", "DT", "DG", "DC", "RA5", "RU5", "RG5", "RC5", "RA3", "RU3", "RG3", "RC3", "RA", "RU", "RG", "RC", "DNA_base");
my @waters = ("SOL", "WAT", "HOH");
my @ions = ("Na", "Mg", "Ca", "Cl", "Zn", "CAL", "ZIN");

# アミノ酸: 1
my @results = grep(/^$residue_name$/, @amino_acids);
if(-1 < $#results){
	return 1;
}

# 核酸: 2
@results = grep(/^$residue_name$/, @nucleic_acids);
if(-1 < $#results){
	return 2;
}

# 水分子: 3
@results = grep(/^$residue_name$/, @waters);
if(-1 < $#results){
	return 3;
}

# イオン: 4
@results = grep(/\s?$residue_name[\s\+]?/i, @ions);
if(-1 < $#results){
	return 4;
}

# その他: 5
return 5;
}

# =============== check_file =============== #
# ファイルチェック
sub check_file{
my $file = shift(@_);

if(! -f $file){
	print " ERROR: No such file: $file\n";
	exit;
}

return $file;
}


# =============== help =============== #
sub help{
my $script_name = basename($0);

print << "HELP";
 AutoFrag Program
 Translate PDB_FILE to fred format file
  \$ $script_name [-s] <PDB_FILE> [> <OUTPUT>]
    -s, --separate: Nucleotide was devided into sugar+phosphate group and base

   and then ...
  \$ fred -o <OUTPUT> <ajf_FILE>

HELP
}
